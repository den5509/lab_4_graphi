# Исследование интерфейсов для управления облачными системами
## Выполнение работы

По данному заданию необходимо найти инструмент для управления Docker хостами или Swarm кластерами. Рассмотрим наиболее популярные интерфейсы. Сведем их в таблицу чтобы определить какой из них нам подойдет:

Интерфейсы для управления | ОС | Языки/платформа | Краткое описание 
:---: | :---: | :---: | :---:
Portainer | Linux, Mac OS X, Windows | Go, JavaScript (Angular) | Web-интерфейс для работы с Docker-хостами и кластерами Docker Swarm. Позволяет управлять контейнерами, образами (умеет забирать их из Docker Hub), сетями, томами. При просмотре контейнеров для каждого из них доступна базовая статистика (использование ресурсов, процессы), логи, подключение к консоли (веб-терминал xterm.js). 
Kitematic (Docker Toolbox) | Mac OS X, Windows | Electron, Node.js, React и AltJS | Стандартный GUI для пользователей Docker в Mac OS X и Windows, который вошёл в состав Docker Toolbox — инсталлятора набора утилит, включающих в себя также Docker Engine, Compose и Machine.
Shipyard | Linux, Mac OS X | Go, Node.js. | система управления ресурсами Docker, в основу которой заложено наличие своего API. API в Shipyard — RESTful на базе формата JSON, совместим на 100% с Docker Remote API, предлагает дополнительные возможности (в частности — аутентификацию и управление списками доступа, логирование всех выполняемых операций). Этот API и является той базой, вокруг которой уже построен веб-интерфейс.
Admiral | Linux, Mac OS X, Windows | Java (фреймворк VMware Xenon) | Платформа от VMware, предназначенная для автоматизированного деплоя контейнеризированных приложений и управления ими на протяжении жизненного цикла. Позиционируется как легковесное решение, призванное упростить жизнь DevOps-инженерам. Веб-интерфейс позволяет управлять хостами с Docker, контейнерами (+ просмотр статистики и логов), шаблонами (образы, интегрированные с Docker Hub), сетями, реестрами, политиками (какие хосты какими контейнерами будут использоваться и как распределять ресурсы). Умеет проверять состояние контейнеров (health checks).
DockStation | Linux, Mac OS X, Windows |  Electron (Chromium, Node.js) | Молодой проект, две главные особенности — ориентированность на разработчиков (не на DevOps-инженеров или сисадминов) с полноценной поддержкой Docker Compose и закрытость кода (бесплатно для использования, а за деньги авторы предлагают персональную поддержку и доработку возможностей). Позволяет не только управлять образами (поддерживается Docker Hub) и контейнерами (+ статистика и логи), но и заводить проекты с визуализацией связей контейнеров, задействованных в проекте.
Simple Docker UI | Linux, Mac OS X, Windows | Electron, Scala.js (+ React on Scala.js) | Простой интерфейс для работы с Docker, использующий Docker Remote API. Позволяет управлять контейнерами и образами (с поддержкой Docker Hub), подключаться к консоли, просматривать историю событий. Имеет механизмы удаления неиспользуемых контейнеров и образов. Проект находится в бета-версии и развивается очень медленно.





```bash
sudo docker run -d -v "/var/run/docker.sock:/var/run/docker.sock" -p 9000:9000 portainer/portainer
```
Опустим рисунок, так как там просто выполнение команды(я просто забыл его зафиксировать)
Потом был создан и запущен первый контейнер 1, с примонтированным к нему томом AllVolume.
Использованная команда:
```bash
docker run -ti --name=Container1 -v AllVolume:/allvolume alpine
```
В томе AllVolume был создан файл, содержащий строку с идентификатором контейнера.
Примененная команда:
```bash
echo "write some information from " + $HOSTNAME > /allvolume/file.txt
```
![alt]({{"/Снимок экрана от 2017-11-15 10-06-13.png" | absolute_url}})
Рисунок 1 — Создание контейнера No1

Далее был создан запущен контейнер 2 с примонтированным ранее созданным томом AllVolume
Использованная команда:
```bash
docker run -ti --name=Container2 --volumes-from Contaier1 alpine
```
Для проверки того, что файлы в томе дейтсвительно общие, было прочитано содержимое файла file.txt, в котором раньше была произведена запись в контейнере 1 использованна команда:
```bash
cat /myvolume/file.txt
```
![alt]({{"/Снимок экрана от 2017-11-15 10-06-53.png" | absolute_url}})
Рисунок 2 — Создание контейнера No2 с примонтированным общим томом

Затем, уже из контейнера 2 в тот же файл была записана строка с идентификатором контейнера. Далее содержимое было прочитано из контейнера 1:

![alt]({{"/Снимок экрана от 2017-11-15 10-08-02.png" | absolute_url}})
Рисунок 3 — Запись в файл из контейнера 2 и чтение из контейнера 1
Для проверки работы при одновременной записи из контейнеров в один и тот же файл, одновременно был запущен цикл с записью аналогичных строк использовалась команда:
```bash
date; for I in `seq 99999`; do echo "write some information from " + $HOSTNAME > /allvolume/file.txt; done; date;
```
![alt]({{"/Снимок экрана от 2017-11-15 10-10-54.png" | absolute_url}})

Рисунок 4 — Запуск циклов записи в файл
![alt]({{"/Снимок экрана от 2017-11-15 10-20-43.png" | absolute_url}})

Рисунок 5 — Часть содержимого файла

---
## Вывод
Доказано, что во время одновременной отработки циклов записи из двух контейнеров в 1 файл, конфликтов не происходит и все строки записываются в файл по мере вызова соответствующей команды, а при одновременной записи в файл, она производилась поочередно, опять же без каких лмбо конфликтов или потерь. 
